# ============ TRIGGER ÚNICO ============
trigger:
  branches:
    include: [ main ]
  paths:
    exclude: [ README.md, .gitignore, azure-pipelines.yml, .gitattributes ]

# ============ VARIABLES ============
variables:
  azureSubscription: 'sc-azure-agromarket'  # MANTENIDO
  appName: 'Az-Planify-Front'               # Destino Planify
  feRoot: '.'
  zipName: 'planify-frontend.zip'

# ============ AGENTE (self-hosted, MANTENIDO) ============
pool:
  name: Default
  demands:
    - agent.name -equals agromarket-agent-win

# ============ STAGE ÚNICO ============
stages:
- stage: Build_And_Deploy
  displayName: Build & Deploy Planify (main)
  jobs:
  - job: job_build_deploy
    displayName: Build & Deploy
    steps:
    - checkout: self
      clean: true
      fetchDepth: 0

    - task: NodeTool@0
      displayName: 'Use Node 20.x'
      inputs:
        versionSpec: '20.x'

    - script: |
        node -v
        npm -v
        echo SOURCES=$(Build.SourcesDirectory)
      displayName: 'Versiones'

    # Quitar budgets en CI (sin límites de tamaño)
    - powershell: |
        $ErrorActionPreference = 'Stop'
        function Remove-PropIfExists([object]$obj, [string]$propName) {
          if ($null -ne $obj) {
            $prop = $obj.PSObject.Properties.Match($propName)
            if ($prop -and $prop.Count -gt 0) { $obj.PSObject.Properties.Remove($propName) | Out-Null }
          }
        }

        $root = "$(feRoot)"
        $angularPath = Join-Path $root 'angular.json'
        if (-not (Test-Path $angularPath)) { throw "No se encontró angular.json en '$root'." }

        $json = Get-Content $angularPath -Raw | ConvertFrom-Json
        if (-not $json.projects) { throw "No se encontró 'projects' en angular.json." }

        foreach ($projProp in $json.projects.PSObject.Properties) {
          $proj = $projProp.Value
          if ($null -eq $proj) { continue }

          $build = $null
          if ($proj.targets -and $proj.targets.build) { $build = $proj.targets.build }
          elseif ($proj.architect -and $proj.architect.build) { $build = $proj.architect.build }
          if ($null -eq $build) { continue }

          Remove-PropIfExists -obj $build -propName 'budgets'
          $cfgs = $null
          if ($build.configurations) { $cfgs = $build.configurations }
          elseif ($build.options -and $build.options.configurations) { $cfgs = $build.options.configurations }
          if ($cfgs) {
            foreach ($cfgProp in $cfgs.PSObject.Properties) {
              Remove-PropIfExists -obj $cfgProp.Value -propName 'budgets'
            }
          }
        }

        ($json | ConvertTo-Json -Depth 100) | Set-Content $angularPath -Encoding UTF8
        Write-Host "Budgets ELIMINADOS para CI."
      displayName: 'Eliminar budgets (sin límites)'

    # Instalar deps y compilar
    - script: |
        cd $(feRoot)
        if not exist package-lock.json ( echo FALTA package-lock.json && exit /b 1 )
        npm config set fund false --global
        npm config set audit false --global
        echo npm ci
        npm ci
        if %ERRORLEVEL% NEQ 0 (
          echo "npm ci falló. Intentando npm install --legacy-peer-deps"
          npm install --legacy-peer-deps
          if %ERRORLEVEL% NEQ 0 exit /b 1
        )
        echo ng build --configuration production --output-path dist --verbose
        npm run build -- --configuration production --output-path dist --verbose
        echo ---- Árbol de dist (nivel 1) ----
        if exist dist ( dir dist ) else ( echo dist no encontrado )
      displayName: 'npm ci & ng build'

    # Empaquetar dist + web.config (robusto con feRoot y búsqueda recursiva)
    - powershell: |
        $ErrorActionPreference = 'Stop'

        $srcRoot = "$(Build.SourcesDirectory)"
        $feRoot  = "$(feRoot)"
        if ([string]::IsNullOrWhiteSpace($feRoot)) { $feRoot = '.' }

        $projRoot = Join-Path $srcRoot $feRoot
        Write-Host "Proyecto (feRoot): $projRoot"
        Write-Host "Listado rápido de $projRoot (2 niveles aprox):"
        # Nota: -Depth no está en Windows PowerShell 5, evitamos usarlo
        Get-ChildItem -Path $projRoot -Recurse -ErrorAction SilentlyContinue | Select-Object -First 200 | ForEach-Object { $_.FullName } | Out-String | Write-Host

        # 1) Ruta esperada por defecto: <feRoot>/dist
        $distRoot = Join-Path $projRoot 'dist'
        $resolved = $false

        if (Test-Path $distRoot) {
          Write-Host "Encontrado dist en: $distRoot"
          # Angular 15+ puede crear dist/<app>/browser
          $firstSub = Get-ChildItem -Directory $distRoot | Select-Object -First 1
          if ($firstSub) {
            $browser = Join-Path $firstSub.FullName 'browser'
            if (Test-Path $browser) {
              $distRoot = $browser
              Write-Host "Usando subcarpeta browser: $distRoot"
            } else {
              $distRoot = $firstSub.FullName
              Write-Host "Usando subcarpeta: $distRoot"
            }
          }
          $resolved = $true
        }

        if (-not $resolved) {
          Write-Warning "No se encontró dist en $distRoot. Intentando detectar automáticamente..."

          # 2) Buscar recursivamente un directorio que contenga un index.html (o browser/index.html)
          $candidate = Get-ChildItem -Path $projRoot -Recurse -Directory -ErrorAction SilentlyContinue `
            | Where-Object {
                (Test-Path (Join-Path $_.FullName 'index.html')) -or
                (Test-Path (Join-Path $_.FullName 'browser\index.html'))
              } `
            | Sort-Object FullName -Descending `
            | Select-Object -First 1

          if ($null -eq $candidate) {
            throw "No se pudo localizar la carpeta de salida de Angular (dist). Revisa el outputPath del build."
          }

          $browserPath = Join-Path $candidate.FullName 'browser'
          if (Test-Path $browserPath) {
            $distRoot = $browserPath
            Write-Host "Detectado dist (browser) en: $distRoot"
          } else {
            $distRoot = $candidate.FullName
            Write-Host "Detectado dist en: $distRoot"
          }
        }

        # 3) Copiar web.config desde la raíz del repo (como indicaste)
        $webConfig = Join-Path $srcRoot 'web.config'
        if (-not (Test-Path $webConfig)) { throw "Falta web.config en la raíz del repo ($srcRoot)." }
        Copy-Item -Force $webConfig (Join-Path $distRoot 'web.config')

        # 4) Comprimir a ZIP de salida
        $outDir  = "$(Build.ArtifactStagingDirectory)"
        New-Item -ItemType Directory -Force -Path $outDir | Out-Null
        $zipPath = Join-Path $outDir "$(zipName)"
        if (Test-Path $zipPath) { Remove-Item -Force $zipPath }

        Write-Host "Creando ZIP: $zipPath desde $distRoot"
        Compress-Archive -Path (Join-Path $distRoot '*') -DestinationPath $zipPath -Force
      displayName: 'Crear ZIP para despliegue'

    # Deploy directo a la Web App Planify (solo desde main)
    - task: AzureWebApp@1
      displayName: 'Deploy a $(appName)'
      inputs:
        azureSubscription: '$(azureSubscription)'  # MANTENIDO
        appType: 'webApp'
        appName: '$(appName)'
        package: '$(Build.ArtifactStagingDirectory)/$(zipName)'
      condition: and(succeeded(), eq(variables['Build.SourceBranchName'], 'main'))
